//! Definitions for the JSON export format from `llvm-cov`.

use std::io::Read;

use camino::Utf8PathBuf;
use color_eyre::{eyre, Help, Result};
use semver::Version;
use serde::Deserialize;

/// Root structure of the JSON output that is generated by `cargo-llvm-cov`/`llvm-cov`.
#[derive(Deserialize)]
#[cfg_attr(test, derive(Debug, PartialEq))]
pub struct JsonExport {
    /// (Likely) semantic version of the export format. We don't check this field, but it should be
    /// at least `2.0.0`.
    pub version: String,
    /// Type of export information contained in the `data` field. We don't check this field, but it
    /// should always be `llvm.coverage.json.export`.
    #[serde(rename = "type")]
    pub ty: String,
    /// The actual export data. It seems to always be exactly one entry in an array.
    ///
    /// Probably this could contain more than one entry, if the report is further processed by
    /// other LLVM utilities. But when the report comes from `cargo-llvm-cov` it's always a single
    /// entry, and that's our main use case.
    pub data: [Export; 1],
    /// Additional contextual information injected by `cargo-llvm-cov`
    pub cargo_llvm_cov: Option<CargoLlvmCov>,
}

impl JsonExport {
    /// Try to parse the export data from the given reader.
    ///
    /// In case of an error, the location of the JSON is reported to better pin-point the location
    /// of an invalid structure, if that was the cause of the error.
    pub fn from_reader(reader: impl Read) -> Result<JsonExport> {
        serde_path_to_error::deserialize::<_, JsonExport>(
            &mut serde_json::Deserializer::from_reader(reader),
        )
        .map_err(|e| {
            let path = e.path().to_string();
            eyre::Report::new(e.into_inner()).note(format!("JSON path: {path}"))
        })
    }
}

/// Coverage data for a single `llvm-cov` run, usually over a single project or workspace.
#[derive(Deserialize)]
#[cfg_attr(test, derive(Debug, PartialEq))]
pub struct Export {
    /// List of coverage information per file.
    pub files: Vec<File>,
    /// Additional coverage information for specific function invocations (as well as the lack of
    /// invocation).
    #[serde(default)]
    pub functions: Vec<Function>,
    /// Overall statistics of the coverage data summed up from all the file and function
    /// information.
    pub totals: Summary,
}

/// Coverage data for a single source code file.
#[derive(Deserialize)]
#[cfg_attr(test, derive(Debug, PartialEq))]
pub struct File {
    /// Absolute path of the file that was tested.
    pub filename: Utf8PathBuf,
    /// Main list of code coverage information, which is described as segments.
    ///
    /// These are elements that usually form a set of pairs and describe the start and end range
    /// that was covered. They must be manually combined back together, but appear to be in proper
    /// order, making it easy to scan over them and start and end segments.
    #[serde(default)]
    pub segments: Vec<Segment>,
    /// Coverage for code branches (like if statements, I assume).
    ///
    /// **Note:** Appears to be unused for Rust projects (as branch coverage support is still
    /// experimental).
    #[serde(default)]
    pub branches: Vec<BranchRegion>,
    /// Coverage for code expansions caused by generics or templates. For example, structs with
    /// generic arguments that get expanded into concrete versions for specific types.
    ///
    /// **Note:** Appears to be unused for Rust projects.
    #[serde(default)]
    pub expansions: Vec<Expansion>,
    /// Coverage statistics summed up for the entire file.
    pub summary: Summary,
}

#[cfg_attr(test, derive(Debug, PartialEq))]
pub struct Segment {
    pub line: u64,
    pub col: u64,
    pub count: u64,
    pub has_count: bool,
    pub is_region_entry: bool,
    pub is_gap_region: bool,
}

impl<'de> Deserialize<'de> for Segment {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct Array(u64, u64, u64, bool, bool, bool);

        Array::deserialize(deserializer).map(|a| Self {
            line: a.0,
            col: a.1,
            count: a.2,
            has_count: a.3,
            is_region_entry: a.4,
            is_gap_region: a.5,
        })
    }
}

impl Segment {
    /// Whether this segment signals the start of a code coverage region.
    pub fn is_start(&self) -> bool {
        self.has_count && self.is_region_entry && !self.is_gap_region
    }

    /// Whether this segment is considered the end of an open code coverage region.
    pub fn is_end(&self) -> bool {
        !self.has_count && !self.is_region_entry && !self.is_gap_region
    }
}

/// Coverage information for a function invocation (or the lack of it).
#[derive(Deserialize)]
#[cfg_attr(test, derive(Debug, PartialEq))]
pub struct Function {
    /// Fully qualified function name in its demangled form.
    #[serde(with = "demangle")]
    pub name: String,
    /// Total invocation count for the function.
    pub count: u64,
    /// Source code regions where the function call happened (or is missing).
    pub regions: Vec<Region>,
    /// Similar to [`File::branches`], but for functions.
    pub branches: Vec<BranchRegion>,
    /// Files in which this function is defined.
    ///
    /// As a function is usually defined in only one place, this should always contain a single
    /// entry.
    pub filenames: [Utf8PathBuf; 1],
}

#[cfg_attr(test, derive(Debug, PartialEq))]
pub struct Region {
    /// Start position of the region (line and column).
    pub start: (u64, u64),
    /// End position of the region (line and column).
    pub end: (u64, u64),
    /// How many times the function was executed in this region.
    pub execution_count: u64,
    /// Unique identifier for the file, but appears to be always `0`.
    pub file_id: u64,
    /// Unique identifier for the expanded file, but appears to be always `0`.
    pub expanded_file_id: u64,
    pub kind: RegionKind,
}

/// Kind of region that is described in [`Region`].
///
/// **Note:** Although there are several kinds, only [`Self::Code`] ever appeared in the coverage
/// data. Probably the other variants are not relevant or not supported for Rust.
#[cfg_attr(test, derive(Debug, PartialEq))]
pub enum RegionKind {
    Code,
    Expansion,
    Skipped,
    Gap,
    Branch,
    /// Fallback value for any unsupported future variants.
    Unknown(u8),
}

impl<'de> Deserialize<'de> for Region {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct Array(u64, u64, u64, u64, u64, u64, u64, u8);

        Array::deserialize(deserializer).map(|a| Self {
            start: (a.0, a.1),
            end: (a.2, a.3),
            execution_count: a.4,
            file_id: a.5,
            expanded_file_id: a.6,
            kind: match a.7 {
                0 => RegionKind::Code,
                1 => RegionKind::Expansion,
                2 => RegionKind::Skipped,
                3 => RegionKind::Gap,
                4 => RegionKind::Branch,
                v => RegionKind::Unknown(v),
            },
        })
    }
}

#[cfg_attr(test, derive(Debug, PartialEq))]
pub struct BranchRegion {
    pub line_start: u64,
    pub column_start: u64,
    pub line_end: u64,
    pub column_end: u64,
    pub execution_count: u64,
    pub false_execution_count: u64,
    pub file_id: u64,
    pub expanded_file_id: u64,
    pub kind: RegionKind,
}

impl<'de> Deserialize<'de> for BranchRegion {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct Array(u64, u64, u64, u64, u64, u64, u64, u64, u8);

        Array::deserialize(deserializer).map(|a| Self {
            line_start: a.0,
            column_start: a.1,
            line_end: a.2,
            column_end: a.3,
            execution_count: a.4,
            false_execution_count: a.5,
            file_id: a.6,
            expanded_file_id: a.7,
            kind: match a.8 {
                0 => RegionKind::Code,
                1 => RegionKind::Expansion,
                2 => RegionKind::Skipped,
                3 => RegionKind::Gap,
                4 => RegionKind::Branch,
                v => RegionKind::Unknown(v),
            },
        })
    }
}

#[derive(Deserialize)]
#[cfg_attr(test, derive(Debug, PartialEq))]
pub struct Expansion {
    pub filenames: Vec<Utf8PathBuf>,
    pub source_region: Region,
    pub target_regions: Vec<Region>,
    pub branches: Vec<BranchRegion>,
}

#[derive(Clone, Deserialize)]
#[cfg_attr(test, derive(Debug, Default, PartialEq))]
pub struct Summary {
    pub lines: CoverageCounts,
    pub functions: CoverageCounts,
    pub instantiations: CoverageCounts,
    pub regions: CoverageCounts2,
    pub branches: CoverageCounts2,
}

/// Sum of coverage counts as part of the [`Summary`].
#[derive(Clone, Deserialize)]
#[cfg_attr(test, derive(Debug, Default, PartialEq))]
pub struct CoverageCounts {
    pub count: u64,
    pub covered: u64,
    pub percent: f64,
}

/// Sum of coverage counts like [`CoverageCounts`], but including the extra [`Self::notcovered`]
/// field, which is only present for [`Summary::regions`] and [`Summary::branches`].
#[derive(Clone, Deserialize)]
#[cfg_attr(test, derive(Debug, Default, PartialEq))]
pub struct CoverageCounts2 {
    pub count: u64,
    pub covered: u64,
    pub notcovered: u64,
    pub percent: f64,
}

/// Contextual information from `cargo-llvm-cov`.
#[derive(Clone, Deserialize)]
#[cfg_attr(test, derive(Debug, PartialEq))]
pub struct CargoLlvmCov {
    /// The version that was used. More reliable than invoking cargo-llvm-cov ourselves, as it may
    /// have changed in the meantime (in case of a local file), or simply being a different one due
    /// to path resolution.
    pub version: Version,
    /// The project's manifest path, as resolved by cargo-llvm-cov. Avoids a mismatch as a
    /// user-provided path has to be passed to both tools.
    pub manifest_path: Utf8PathBuf,
}

mod demangle {
    //! Custom deserializer that demangles Rust type and function names back into readable variants.

    use std::fmt;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<String, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_str(ValueVisitor)
    }

    struct ValueVisitor;

    impl<'de> serde::de::Visitor<'de> for ValueVisitor {
        type Value = String;

        fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
            formatter.write_str("possibly mangled rust identifier")
        }

        fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
        where
            E: serde::de::Error,
        {
            Ok(format!("{:#}", rustc_demangle::demangle(v)))
        }
    }
}

#[cfg(test)]
mod tests {
    #![allow(clippy::too_many_lines)]

    use camino::Utf8PathBuf;
    use semver::Version;
    use serde_json::json;

    use crate::schema::CargoLlvmCov;

    use super::{Export, File, Function, JsonExport, Region, RegionKind, Segment, Summary};

    #[test]
    fn minimum() {
        let input = json! {{
            "version": "2.0.0",
            "type": "llvm.coverage.json.export",
            "data": [{
                "files": [],
                "totals": {
                    "lines": {
                        "count": 0,
                        "covered": 0,
                        "percent": 0.0
                    },
                    "functions": {
                        "count": 0,
                        "covered": 0,
                        "percent": 0.0
                    },
                    "instantiations": {
                        "count": 0,
                        "covered": 0,
                        "percent": 0.0
                    },
                    "regions": {
                        "count": 0,
                        "covered": 0,
                        "notcovered": 0,
                        "percent": 0.0
                    },
                    "branches": {
                        "count": 0,
                        "covered": 0,
                        "notcovered": 0,
                        "percent": 0.0
                    }
                }
            }]
        }};
        let expect = JsonExport {
            version: "2.0.0".to_owned(),
            ty: "llvm.coverage.json.export".to_owned(),
            data: [Export {
                files: vec![],
                functions: vec![],
                totals: Summary::default(),
            }],
            cargo_llvm_cov: None,
        };

        assert_eq!(expect, serde_json::from_value::<JsonExport>(input).unwrap());
    }

    #[test]
    fn basic() {
        let input = json! {{
            "version": "2.0.0",
            "type": "llvm.coverage.json.export",
            "data": [{
                "files": [{
                    "filename": "src/main.rs",
                    "segments": [
                        [0, 0, 0, true, true, false],
                        [0, 0, 0, false, false, false]
                    ],
                    "summary": {
                        "lines": {
                            "count": 0,
                            "covered": 0,
                            "percent": 0.0
                        },
                        "functions": {
                            "count": 0,
                            "covered": 0,
                            "percent": 0.0
                        },
                        "instantiations": {
                            "count": 0,
                            "covered": 0,
                            "percent": 0.0
                        },
                        "regions": {
                            "count": 0,
                            "covered": 0,
                            "notcovered": 0,
                            "percent": 0.0
                        },
                        "branches": {
                            "count": 0,
                            "covered": 0,
                            "notcovered": 0,
                            "percent": 0.0
                        }
                    }
                }],
                "functions": [{
                    "name": "_RNvCsiyECgj7cfTq_6sample4main",
                    "count": 0,
                    "regions": [[1, 0, 1, 1, 0, 0, 0, 0]],
                    "branches": [],
                    "filenames": ["src/main.rs"]
                }],
                "totals": {
                    "lines": {
                        "count": 0,
                        "covered": 0,
                        "percent": 0.0
                    },
                    "functions": {
                        "count": 0,
                        "covered": 0,
                        "percent": 0.0
                    },
                    "instantiations": {
                        "count": 0,
                        "covered": 0,
                        "percent": 0.0
                    },
                    "regions": {
                        "count": 0,
                        "covered": 0,
                        "notcovered": 0,
                        "percent": 0.0
                    },
                    "branches": {
                        "count": 0,
                        "covered": 0,
                        "notcovered": 0,
                        "percent": 0.0
                    }
                }
            }]
        }};
        let expect = JsonExport {
            version: "2.0.0".to_owned(),
            ty: "llvm.coverage.json.export".to_owned(),
            data: [Export {
                files: vec![File {
                    filename: "src/main.rs".into(),
                    segments: vec![
                        Segment {
                            line: 0,
                            col: 0,
                            count: 0,
                            has_count: true,
                            is_region_entry: true,
                            is_gap_region: false,
                        },
                        Segment {
                            line: 0,
                            col: 0,
                            count: 0,
                            has_count: false,
                            is_region_entry: false,
                            is_gap_region: false,
                        },
                    ],
                    branches: vec![],
                    expansions: vec![],
                    summary: Summary::default(),
                }],
                functions: vec![Function {
                    name: "sample::main".to_owned(),
                    count: 0,
                    regions: vec![Region {
                        start: (1, 0),
                        end: (1, 1),
                        execution_count: 0,
                        file_id: 0,
                        expanded_file_id: 0,
                        kind: RegionKind::Code,
                    }],
                    branches: vec![],
                    filenames: ["src/main.rs".into()],
                }],
                totals: Summary::default(),
            }],
            cargo_llvm_cov: None,
        };

        assert_eq!(expect, serde_json::from_value::<JsonExport>(input).unwrap());
    }

    #[test]
    fn cargo_llvm_cov() {
        let input = json! {{
            "version": "2.0.0",
            "type": "llvm.coverage.json.export",
            "data": [{
                "files": [],
                "functions": [],
                "totals": {
                    "lines": {
                        "count": 0,
                        "covered": 0,
                        "percent": 0.0
                    },
                    "functions": {
                        "count": 0,
                        "covered": 0,
                        "percent": 0.0
                    },
                    "instantiations": {
                        "count": 0,
                        "covered": 0,
                        "percent": 0.0
                    },
                    "regions": {
                        "count": 0,
                        "covered": 0,
                        "notcovered": 0,
                        "percent": 0.0
                    },
                    "branches": {
                        "count": 0,
                        "covered": 0,
                        "notcovered": 0,
                        "percent": 0.0
                    }
                }
            }],
            "cargo_llvm_cov": {
                "version": "0.5.33",
                "manifest_path": "/home/me/llvm-cov-pretty/Cargo.toml"
            }
        }};
        let expect = JsonExport {
            version: "2.0.0".to_owned(),
            ty: "llvm.coverage.json.export".to_owned(),
            data: [Export {
                files: vec![],
                functions: vec![],
                totals: Summary::default(),
            }],
            cargo_llvm_cov: Some(CargoLlvmCov {
                version: Version::new(0, 5, 33),
                manifest_path: Utf8PathBuf::from("/home/me/llvm-cov-pretty/Cargo.toml"),
            }),
        };

        assert_eq!(expect, serde_json::from_value::<JsonExport>(input).unwrap());
    }
}
