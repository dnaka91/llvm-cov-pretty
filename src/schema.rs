//! Definitions for the JSON export format from `llvm-cov`.

use std::io::Read;

use camino::Utf8PathBuf;
use color_eyre::{eyre, Help, Result};
use serde::Deserialize;

/// Root structure of the JSON output that is generated by `cargo-llvm-cov`/`llvm-cov`.
#[derive(Deserialize)]
pub struct JsonExport {
    /// (Likely) semantic version of the export format. We don't check this field, but it should be
    /// at least `2.0.0`.
    pub version: String,
    /// Type of export information contained in the `data` field. We don't check this field, but it
    /// should always be `llvm.coverage.json.export`.
    #[serde(rename = "type")]
    pub ty: String,
    /// The actual export data. It seems to always be exactly one entry in an array.
    ///
    /// Probably this could contain more than one entry, if the report is further processed by
    /// other LLVM utilities. But when the report comes from `cargo-llvm-cov` it's always a single
    /// entry, and that's our main use case.
    pub data: [Export; 1],
}

impl JsonExport {
    /// Try to parse the export data from the given reader.
    ///
    /// In case of an error, the location of the JSON is reported to better pin-point the location
    /// of an invalid structure, if that was the cause of the error.
    pub fn from_reader(reader: impl Read) -> Result<JsonExport> {
        serde_path_to_error::deserialize::<_, JsonExport>(
            &mut serde_json::Deserializer::from_reader(reader),
        )
        .map_err(|e| {
            let path = e.path().to_string();
            eyre::Report::new(e).note(format!("JSON path: {path}"))
        })
    }
}

/// Coverage data for a single `llvm-cov` run, usually over a single project or workspace.
#[derive(Deserialize)]
pub struct Export {
    /// List of coverage information per file.
    pub files: Vec<File>,
    /// Additional coverage information for specific function invocations (as well as the lack of
    /// invocation).
    #[serde(default)]
    pub functions: Vec<Function>,
    /// Overall statistics of the coverage data summed up from all the file and function
    /// information.
    pub totals: Summary,
}

/// Coverage data for a single source code file.
#[derive(Deserialize)]
pub struct File {
    /// Absolute path of the file that was tested.
    pub filename: Utf8PathBuf,
    /// Main list of code coverage information, which is described as segments.
    ///
    /// These are elements that usually form a set of pairs and describe the start and end range
    /// that was covered. They must be manually combined back together, but appear to be in proper
    /// order, making it easy to scan over them and start and end segments.
    #[serde(default)]
    pub segments: Vec<Segment>,
    /// Coverage for code branches (like if statements, I assume).
    ///
    /// **Note:** Appears to be unused for Rust projects (as branch coverage support is still
    /// experimental).
    #[serde(default)]
    pub branches: Vec<BranchRegion>,
    /// Coverage for code expansions caused by generics or templates. For example, structs with
    /// generic arguments that get expanded into concrete versions for specific types.
    ///
    /// **Note:** Appears to be unused for Rust projects.
    #[serde(default)]
    pub expansions: Vec<Expansion>,
    /// Coverage statistics summed up for the entire file.
    pub summary: Summary,
}

pub struct Segment {
    pub line: u64,
    pub col: u64,
    pub count: u64,
    pub has_count: bool,
    pub is_region_entry: bool,
    pub is_gap_region: bool,
}

impl<'de> Deserialize<'de> for Segment {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct Array(u64, u64, u64, bool, bool, bool);

        Array::deserialize(deserializer).map(|a| Self {
            line: a.0,
            col: a.1,
            count: a.2,
            has_count: a.3,
            is_region_entry: a.4,
            is_gap_region: a.5,
        })
    }
}

impl Segment {
    /// Whether this segment signals the start of a code coverage region.
    pub fn is_start(&self) -> bool {
        self.has_count && self.is_region_entry && !self.is_gap_region
    }

    /// Whether this segment is considered the end of an open code coverage region.
    pub fn is_end(&self) -> bool {
        !self.has_count && !self.is_region_entry && !self.is_gap_region
    }
}

/// Coverage information for a function invocation (or the lack of it).
#[derive(Deserialize)]
pub struct Function {
    /// Fully qualified function name in its demangled form.
    #[serde(with = "demangle")]
    pub name: String,
    /// Total invocation count for the function.
    pub count: u64,
    /// Source code regions where the function call happened (or is missing).
    pub regions: Vec<Region>,
    /// Similar to [`File::branches`], but for functions.
    pub branches: Vec<BranchRegion>,
    /// Files in which this function is defined.
    ///
    /// As a function is usually defined in only one place, this should always contain a single
    /// entry.
    pub filenames: [Utf8PathBuf; 1],
}

pub struct Region {
    /// Start position of the region (line and column).
    pub start: (u64, u64),
    /// End position of the region (line and column).
    pub end: (u64, u64),
    /// How many times the function was executed in this region.
    pub execution_count: u64,
    /// Unique identifier for the file, but appears to be always `0`.
    pub file_id: u64,
    /// Unique identifier for the expanded file, but appears to be always `0`.
    pub expanded_file_id: u64,
    pub kind: RegionKind,
}

/// Kind of region that is described in [`Region`].
///
/// **Note:** Although there are several kinds, only [`Self::Code`] ever appeared in the coverage
/// data. Probably the other variants are not relevant or not supported for Rust.
pub enum RegionKind {
    Code,
    Expansion,
    Skipped,
    Gap,
    Branch,
    /// Fallback value for any unsupported future variants.
    Unknown(u8),
}

impl<'de> Deserialize<'de> for Region {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct Array(u64, u64, u64, u64, u64, u64, u64, u8);

        Array::deserialize(deserializer).map(|a| Self {
            start: (a.0, a.1),
            end: (a.2, a.3),
            execution_count: a.4,
            file_id: a.5,
            expanded_file_id: a.6,
            kind: match a.7 {
                0 => RegionKind::Code,
                1 => RegionKind::Expansion,
                2 => RegionKind::Skipped,
                3 => RegionKind::Gap,
                4 => RegionKind::Branch,
                v => RegionKind::Unknown(v),
            },
        })
    }
}

pub struct BranchRegion {
    pub line_start: u64,
    pub column_start: u64,
    pub line_end: u64,
    pub column_end: u64,
    pub execution_count: u64,
    pub false_execution_count: u64,
    pub file_id: u64,
    pub expanded_file_id: u64,
    pub kind: RegionKind,
}

impl<'de> Deserialize<'de> for BranchRegion {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct Array(u64, u64, u64, u64, u64, u64, u64, u64, u8);

        Array::deserialize(deserializer).map(|a| Self {
            line_start: a.0,
            column_start: a.1,
            line_end: a.2,
            column_end: a.3,
            execution_count: a.4,
            false_execution_count: a.5,
            file_id: a.6,
            expanded_file_id: a.7,
            kind: match a.8 {
                0 => RegionKind::Code,
                1 => RegionKind::Expansion,
                2 => RegionKind::Skipped,
                3 => RegionKind::Gap,
                4 => RegionKind::Branch,
                v => RegionKind::Unknown(v),
            },
        })
    }
}

#[derive(Deserialize)]
pub struct Expansion {
    pub filenames: Vec<Utf8PathBuf>,
    pub source_region: Region,
    pub target_regions: Vec<Region>,
    pub branches: Vec<BranchRegion>,
}

#[derive(Clone, Deserialize)]
#[cfg_attr(test, derive(Default))]
pub struct Summary {
    pub lines: CoverageCounts,
    pub functions: CoverageCounts,
    pub instantiations: CoverageCounts,
    pub regions: CoverageCounts2,
    pub branches: CoverageCounts2,
}

/// Sum of coverage counts as part of the [`Summary`].
#[derive(Clone, Deserialize)]
#[cfg_attr(test, derive(Default))]
pub struct CoverageCounts {
    pub count: u64,
    pub covered: u64,
    pub percent: f64,
}

/// Sum of coverage counts like [`CoverageCounts`], but including the extra [`Self::notcovered`]
/// field, which is only present for [`Summary::regions`] and [`Summary::branches`].
#[derive(Clone, Deserialize)]
#[cfg_attr(test, derive(Default))]
pub struct CoverageCounts2 {
    pub count: u64,
    pub covered: u64,
    pub notcovered: u64,
    pub percent: f64,
}

mod demangle {
    //! Custom deserializer that demangles Rust type and function names back into readable variants.

    use std::fmt;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<String, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_str(ValueVisitor)
    }

    struct ValueVisitor;

    impl<'de> serde::de::Visitor<'de> for ValueVisitor {
        type Value = String;

        fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
            formatter.write_str("possibly mangled rust identifier")
        }

        fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
        where
            E: serde::de::Error,
        {
            Ok(format!("{:#}", rustc_demangle::demangle(v)))
        }
    }
}
